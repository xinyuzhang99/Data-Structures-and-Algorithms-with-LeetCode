# Bit Manipulation 位操作

<img src="/Users/xinyuzhang/Library/Application Support/typora-user-images/image-20220824164628325.png" alt="image-20220824164628325" style="zoom:50%;" />

**Note:** Python bitwise operators work only on integers.

- **常见的位操作**

  ```python
  # 1. 利用或操作 | 和空格将英文字符转换为小写
  ('a' | '') = 'a'
  ('A' | '') = 'a'
  
  # 2. 利用与操作 & 和下划线将英文字符转换为大写
  ('b' & '_') = 'B'
  ('B' & '_') = 'B'
  
  # 3. 利用异或操作 ^ 和空格进行英文字符大小写互换
  ('d' ^ '') = 'D'
  ('D' ^ ' ') = 'd'
  
  # 4. 判断两个数是否异号：这个技巧还是很实用的，利用的是补码编码的符号位。如果不用位运算来判断是否异号，需要使用 if else 分支，还挺麻烦的。读者可能想利用乘积或者商来判断两个数是否异号，但是这种处理方式可能造成溢出，从而出现错误。
  x, y = -1, 2
  f = ((x ^ y) < 0)     # True
  
  x, y = 3, 2
  f = ((x ^ y) < 0)     # False
  
  # 5. 不用临时变量交换两个数
  a = 1, b = 2;
  a ^= b  # a = a ^ b
  b ^= a
  a ^= b
  # 现在 a = 2, b = 1
  
  # 6. 加一
  n = 1
  n = -~n
  # 现在 n = 2
  
  # 7. 减一
  n = 2
  n = ~-n
  # 现在 n = 1
  
  # 整数集合set位运算
  # 整数集合做标志时，比如回溯时的visited标志数组
  vstd 访问 i ：vstd | (1 << i)
  vstd 离开 i ：vstd & ~(1 << i)
  vstd 不包含 i : not vstd & (1 << i)
  
  并集 ：A | B
  交集 ：A & B
  全集 ：(1 << n) - 1
  补集 ：((1 << n) - 1) ^ A
  子集 ：(A & B) == B
  判断是否是 2 的幂 ：A & (A - 1) == 0
  最低位的 1 变为 0 ：n &= (n - 1)
  最低位的 1：A & (-A)，最低位的 1 一般记为 lowbit(A)
  ```

- **`n & (n-1)`的运用**

  **`n & (n-1)` 这个操作是算法中常见的，作用是消除数字 `n` 的二进制表示中的最后一个 1**。

  <img src="https://labuladong.github.io/algo/images/%e4%bd%8d%e6%93%8d%e4%bd%9c/1.png" alt="img" style="zoom:50%;" />

  其核心逻辑就是，`n - 1` 一定可以消除最后一个 1，同时把其后的 0 都变成 1，这样再和 `n` 做一次 `&` 运算，就可以仅仅把最后一个 1 变成 0 了。 

  - 1、计算汉明权重（Hamming Weight） 191. [Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/description/)
  - 2、判断一个数是不是 2 的指数

## 1. 191 [Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/description/)

|  Category  |  Difficulty   |                             Tags                             |
| :--------: | :-----------: | :----------------------------------------------------------: |
| algorithms | Easy (62.05%) | [`bit-manipulation`](https://leetcode.com/tag/bit-manipulation) |

Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the [Hamming weight](http://en.wikipedia.org/wiki/Hamming_weight)).

**Note:**

- Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
- In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two's_complement). Therefore, in **Example 3**, the input represents the signed integer. `-3`.

**Example 1:**

```
Input: n = 00000000000000000000000000001011
Output: 3
Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.
```

**Example 2:**

```
Input: n = 00000000000000000000000010000000
Output: 1
Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.
```

**Example 3:**

```
Input: n = 11111111111111111111111111111101
Output: 31
Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.
```

**Constraints:**

- The input must be a **binary string** of length `32`.

**Follow up:** If this function is called many times, how would you optimize it?

- **Solution**

  - <u>Method 1: using remainder to check if each digit is 1</u>

    --> 直接循环检查给定整数 n 的二进制位的每一位是否为 1。具体代码中，当检查第 i 位时，我们可以让 n 与 $2^i$ 进行与运算，当且仅当 n 的第 i 位为 1 时，运算结果不为 0。

    ```python
    def hammingWeight(self, n: int) -> int:
      res = 0
      while n:
        # res += 1 if n % 2 == 1 else 0
        res += n % 2
        # n = n >> 1
        n >>= 1
      return res
    ```

    - Time complexity: O(32) = O(1) --> every string is of length 32

      Space complexity: O(1)

  - <u>Method 2: Optimization `n & (n - 1)`</u> --> <font color=blue>**[Follow-up]**</font>

    **`n & (n-1)` 这个操作是算法中常见的，作用是消除数字 `n` 的二进制表示中的最后一个 1**。--> `n - 1` makes sure the rightmost 1 bit changes to 0 bit; `n & (n - 1)` makes other bits of the string remain the same

    这样我们可以利用这个位运算的性质加速我们的检查过程，在实际代码中，我们不断让当前的 n 与 n−1 做与运算，直到 n 变为 0 即可。因为每次运算会使得 n 的最低位的 1 被翻转，因此运算次数就等于 n 的二进制位中 1 的个数。

    ```python
    def hammingWeight(self, n: int) -> int:
      res = 0
      while n:
        # n = n & (n - 1)
        n &= n - 1
        res += 1
      return res
    ```

    - Time complexity: O(32) = O(1) --> every string is of length 32, <font color=red>but no need to implement division calculations each time</font>

      Space complexity: O(1)

  - <u>Method 3: apply Python library functions</u>

    在 Python 语言中，使用 `bin()` 函数可以得到一个整数的二进制字符串

    ```python
    def hammingWeight(self, n: int) -> int:
      return bin(n).count('1')
    ```

    <font color=red>需要注意的是，二进制字符串是以 "0b" 开头，所以如果题目要问的是二进制中 0 的个数，需要注意答案是 `bin(n).count("0") - 1`</font>

    - Time complexity: O(32) = O(1) --> every string is of length 32

      Space complexity: O(32)

## 2. 231 [Power of Two](https://leetcode.com/problems/power-of-two/description/)

|  Category  |  Difficulty   |                             Tags                             |
| :--------: | :-----------: | :----------------------------------------------------------: |
| algorithms | Easy (45.06%) | [`math`](https://leetcode.com/tag/math); [`bit-manipulation`](https://leetcode.com/tag/bit-manipulation) |

Given an integer `n`, return *`true` if it is a power of two. Otherwise, return `false`*.

An integer `n` is a power of two, if there exists an integer `x` such that `n == 2x`. 

**Example 1:**

```
Input: n = 1
Output: true
Explanation: 20 = 1
```

**Example 2:**

```
Input: n = 16
Output: true
Explanation: 24 = 16
```

**Example 3:**

```
Input: n = 3
Output: false
```

**Constraints:**

- `-231 <= n <= 231 - 1`

**Follow up:** Could you solve it without loops/recursion?

- **Solution**

  <font color=red>**注意：0和负数都不是2的幂**</font>

  - <u>Method 1: common sense</u>

    --> if a value is a power of two --> at each time, n % 2 == 0 until n = 1

    ```python
    def isPowerOfTwo(self, n: int) -> bool:
      if n < 1:
        return False
      while n > 1:
        if n % 2 == 1:
          return False
        n /= 2
      return True
    
    ## Simplified Version
    def isPowerOfTwo(self, n: int) -> bool:
      while n > 1:
        if n % 2 != 0:
          return False
        n /= 2
      return n >= 1 and True
    ```

    - Time complexity: O(n)

      Space complexity: O(1)

  - <u>Method 2: bit manipulation</u> --> <font color=blue>**[Follow-up]**</font>

    一个数 *n* 是 2 的幂，当且仅当 *n* 是正整数，并且 *n* 的二进制表示中仅包含 1 个 1。

    ```
    2^0 = 1 = 0b0001
    2^1 = 2 = 0b0010
    2^2 = 4 = 0b0100
    ```

    <img src="/Users/xinyuzhang/Library/Application Support/typora-user-images/image-20220824222810906.png" alt="image-20220824222810906" style="zoom:40%;" />

    ```python
    def isPowerOfTwo(self, n: int) -> bool:
      if n <= 0:
        return False
    
      return (n & (n - 1)) == 0
    
    ## Simplified Version
    def isPowerOfTwo(self, n: int) -> bool:
      return n > 0 and (n & (n - 1)) == 0
    ```

    Time complexity: O(1)

    Space complexity: O(1)